// Model that replays the trace generated by main.c

#include "spin_input_trail.pml"

#define NEW 0
#define RUNNING 1
#define BLOCKED 2
#define TERMINATED 3

typedef Task {
  int id;
  byte state;
  int hash;
  int hash_start;
  int hash_end;
  int hash_progress;
  byte p
};

Task task_data[MAX_TASKS];
byte task_count = MAX_TASKS;

int id, hash, hash_start, hash_end, hash_progress;
byte state, p;

int execution_time = 0;

inline run_scheduler() {
  do
  :: nempty(trail) ->
    
    trail?id, state, hash, hash_start, hash_end, hash_progress, p;

    d_step {
      task_data[id].state = state;

      if
      :: state == TERMINATED -> 
          task_count--;
      :: else -> skip;
      fi;
    }
  :: empty(trail) && trail_index < TRAIL_COUNT  ->
    execution_time++;
    
    trail_feeder();
  :: empty(trail) && trail_index >= TRAIL_COUNT -> break;
  od;
}

inline trail_feeder() {
  int i = 0;

  do
  :: i < 2 -> // Load in two task-states (which corresponds to 1 unit of execution time)
      d_step {
        c_code {
          now.id = trail_data[now.trail_index].id;
          now.state = trail_data[now.trail_index].state;
          now.hash = trail_data[now.trail_index].hash;
          now.hash_start = trail_data[now.trail_index].hash_start;
          now.hash_end = trail_data[now.trail_index].hash_end;
          now.hash_progress = trail_data[now.trail_index].hash_progress;
          now.p = trail_data[now.trail_index].p;
        }

        trail_index++;
        
        trail!id, state, hash, hash_start, hash_end, hash_progress, p;

        i++;
      }
  :: else -> break;
  od;
}

init {
  // Load in tasks to queue
  run init_trace();

  bool signal;
  go_signal?signal;

  run_scheduler();
}

#include "ltl_statements.pml"