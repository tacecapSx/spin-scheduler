// Model that replays the trace generated by main.c

#include "spin_input_trail.pml"

#define NEW 0
#define RUNNING 1
#define BLOCKED 2
#define TERMINATED 3

typedef Task {
  int id;
  byte state;
  bool entered_running;
  int hash;
  int hash_start;
  int hash_end;
  int hash_progress;
  byte p
};

Task task_data[MAX_TASKS];
byte task_count = MAX_TASKS;

int id, hash, hash_start, hash_end, hash_progress;
byte state, p;

int execution_time = 0;

inline run_scheduler() {
  do
  :: nempty(trail) ->
    
    trail?id, state, hash, hash_start, hash_end, hash_progress, p;

    atomic {
      // Increment execution time
      if
      :: state == RUNNING ->
        execution_time++;
      :: else -> skip;
      fi;

      task_data[id].p = p;
      
      // Set the entered running signal for verification
      task_data[id].entered_running = (state == RUNNING);
      task_data[id].state = state;
      task_data[id].entered_running = false;

      if
      :: state == TERMINATED -> 
          task_count--;
      :: else -> skip;
      fi;
    }
  :: empty(trail) && trail_index < TRAIL_COUNT  ->
    trail_feeder();
  :: empty(trail) && trail_index >= TRAIL_COUNT -> break;
  od;
}

inline trail_feeder() {
  d_step {
    c_code {
      now.id = trail_data[now.trail_index].id;
      now.state = trail_data[now.trail_index].state;
      now.hash = trail_data[now.trail_index].hash;
      now.hash_start = trail_data[now.trail_index].hash_start;
      now.hash_end = trail_data[now.trail_index].hash_end;
      now.hash_progress = trail_data[now.trail_index].hash_progress;
      now.p = trail_data[now.trail_index].p;
    }

    trail_index++;
    
    trail!id, state, hash, hash_start, hash_end, hash_progress, p;
  }
}

init {
  // Load in tasks to queue
  run init_trace();

  bool signal;
  go_signal?signal;

  run_scheduler();
}

ltl task_count_will_become_zero_and_be_bounded {
  [] (task_count <= MAX_TASKS)
    &&
  [] <> (task_count == 0)
}

#include "ltl_statements.pml"